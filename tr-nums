#!/usr/bin/env python
import sys
from argparse import ArgumentParser, ArgumentTypeError
from fractions import Fraction
from functools import lru_cache
from math import log10
from signal import SIGINT, SIGPIPE, SIG_DFL, signal
from sys import argv, stderr, stdout
from typing import Callable, Iterator, NoReturn, Union

import scipy

FractionStr = Callable[[Fraction], str]
Number = Union[Fraction, float, int]
NumberGenerator = Iterator[Fraction]


@lru_cache(maxsize=None)
def gamma(x: Number):
    """
    A memoized version of the Gamma function to improve performance.
    Note the return type to aid in chaining floating point operations.

    :param x: A value for which to compute the gamma function.
    :type x: Fraction | float | int

    :return: The computed value of Gamma(x).
    :rtype: float

    :Examples:
    >>> gamma(1)
    1.0
    >>> gamma(2)
    1.0
    >>> gamma(4)
    6.0
    """
    return scipy.special.gamma(float(x))


def inv_tr_nums(n: Number, d: Number) -> NumberGenerator:
    """
    Generate inverse triangular numbers.
    Avoid negative integer positions and zero.

    :param n: The starting position for the triangular number sequence.
    :type n: Fraction | float | int
    :param d: The dimension for the generalized triangular number.
    :type d: Fraction | float | int

    :return: The next inverse triangular number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_tr_nums(1, 2)
    >>> next(gen)
    Fraction(1, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    >>> # Negative triangular numbers
    >>> gen = inv_tr_nums(-0.5, 2)
    >>> next(gen)
    Fraction(-8, 1)
    """
    while True:
        # yield d * beta(n, n + d)
        yield 1 / Fraction((gamma(n + d) / (gamma(n) * gamma(d + 1))))
        n += 1


def inv_gap_nums(n: Number, d: Number) -> NumberGenerator:
    """
    Generate the preceding "gap" number inverse triangular numbers.

    :param n: The starting position for the preceding gap number.
    :type n: Fraction | float | int
    :param d: The dimension for the preceding gap number.
    :type d: Fraction | float | int

    :return: The next preceding gap number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_gap_nums(1, 2)
    >>> next(gen)
    Fraction(0, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    gap = Fraction(-1)
    tr_gen = inv_tr_nums(n, d)
    # Skip ahead -- DOES NOT WORK for negative indices!
    for _ in range(int(n - 1)):
        gap += next(tr_gen)
    while True:
        gap += next(tr_gen)
        yield gap


def fraction_str_patch(self: Fraction,
                       original_str: FractionStr = Fraction.__str__) \
        -> str:
    """
    Pretty print by possibly rounding the denominator and reducing to
    simplest terms.

    :param self: The fraction to possibly round.
    :type self: Fraction
    :param original_str: The original ``__str__`` method.
    :type original_str: FractionStr

    :return: The possibly rounded fraction as a string.
    :rtype: Fraction

    :Examples:
    >>> args.round_fractions = 2
    >>> fraction_str_patch(Fraction(1, 2))
    '1/2'
    >>> fraction_str_patch(Fraction(101, 323))
    '101/323'
    """
    d = self.denominator
    if d > 0:
        digits = int(log10(d)) + 1
    elif d == 0:  # TODO: Denominator cannot be 0
        digits = 1
    else:
        digits = int(log10(-d)) + 1

    if args.round_fractions is None:
        return original_str(self)
    else:
        return original_str(
            self.limit_denominator(10 ** max(args.round_fractions, digits)))


def main():
    # Be nice about ^C and pipes
    signal(SIGINT, SIG_DFL)
    signal(SIGPIPE, SIG_DFL)

    # Turn tracebacks to standard script error messages
    def handle_exceptions(_, exception, __) -> NoReturn:
        print(f'{argv[0]}: {exception}', file=stderr)
        exit(1)

    sys.excepthook = handle_exceptions

    start = args.start
    dimension = args.dimension

    tr_gen = inv_tr_nums(start, dimension)
    gap_gen = inv_gap_nums(start, dimension)

    # Monkey patch Fraction to respect rounding flags
    Fraction.__str__ = fraction_str_patch

    while True:
        print(f'{next(tr_gen)} {next(gap_gen)}')
        stdout.flush()


def parse_args():
    def parse_fraction(value):
        try:
            return Fraction(value)
        except ValueError:
            raise ArgumentTypeError(f"Invalid fraction value: {value}")

    parser = ArgumentParser(
        description='Print inverse triangular numbers and their gaps.'
    )
    parser.add_argument(
        '-d',
        '--dimension',
        type=parse_fraction,
        default=2,
        metavar='DIM',
        help='generate %(metavar)s-dimensional triangular numbers, can be '
             'non-integral (default: %(default)s)'
    )
    parser.add_argument(
        '-i',
        '--start',
        type=parse_fraction,
        default=1,
        metavar='POS',
        help='start at the %(metavar)s-th triangular number, can be '
             'non-integral (default: %(default)s)'
    )
    parser.add_argument(
        '-r',
        '--round-fractions',
        type=int,
        default=None,
        metavar='DIGITS',
        help='round floating point denominators to %(metavar)s digits'
    )
    parser.add_argument(
        '-T',
        '--unit-tests',
        action='store_true',
        help='run unit tests instead of printing'
    )

    return parser.parse_args()


def unit_tests():
    from doctest import testmod
    testmod()


if __name__ == '__main__':
    args = parse_args()

    if args.unit_tests:
        unit_tests()
    else:
        main()
