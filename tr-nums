#!/usr/bin/env python
from argparse import ArgumentParser, ArgumentTypeError
from fractions import Fraction
from functools import lru_cache
from signal import SIGPIPE, SIG_DFL, signal
from sys import argv, stderr, stdout
from typing import Generator, NoReturn, Union

import scipy

Number = Union[Fraction, float, int]
NumberGenerator = Generator[Fraction, None, None]


def error(x: Union[Exception, str]) -> NoReturn:
    print(f'{argv[0]}: {x}', file=stderr)
    exit(1)


@lru_cache(maxsize=None)
def gamma(x: Number):
    """
    A memoized version of the Gamma function to improve performance.
    Note the return type to aid in chaining floating point operations.

    :param x: A value for which to compute the gamma function.
    :type x: Fraction | float | int

    :return: The computed value of Gamma(x).
    :rtype: float

    :Examples:
    >>> gamma(1)
    1.0
    >>> gamma(2)
    1.0
    >>> gamma(4)
    6.0
    """
    return scipy.special.gamma(float(x))


def inv_tr_nums(n: Number, d: Number) -> NumberGenerator:
    """
    Generate inverse triangular numbers.

    :param n: The starting position for the triangular number sequence.
    :type n: Fraction | float | int
    :param d: The dimension for the generalized triangular number.
    :type d: Fraction | float | int

    :return: The next inverse triangular number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_tr_nums(1, 2)
    >>> next(gen)
    Fraction(1, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    while True:
        try:
            # yield d * beta(n, n + d)
            yield 1 / Fraction((gamma(n + d) / (gamma(n) * gamma(d + 1))))
            n += 1
        except OverflowError as e:
            error(e)


def inv_gap_nums(n: Number, d: Number) -> NumberGenerator:
    """
    Generate the preceding "gap" number inverse triangular numbers.

    :param n: The starting position for the preceding gap number.
    :type n: Fraction | float | int
    :param d: The dimension for the preceding gap number.
    :type d: Fraction | float | int

    :return: The next preceding gap number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_gap_nums(1, 2)
    >>> next(gen)
    Fraction(0, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    x = Fraction(-1)
    gen_inv_tr_nums = inv_tr_nums(n, d)
    # Skip ahead -- DOES NOT WORK for negative indices!
    for _ in range(int(n - 1)):
        x += next(gen_inv_tr_nums)
    while True:
        x += next(gen_inv_tr_nums)
        yield x


def pp(x: Fraction):
    """
    Pretty print by possibly rounding the denominator and reducing to
    simplest terms.

    :param x: The number to possibly round.
    :type x: Fraction

    :return: The possibly rounded number.
    :rtype: Fraction

    :Examples:
    >>> args.round_fractions = 2
    >>> pp(Fraction(1, 2))
    Fraction(1, 2)
    >>> pp(Fraction(101010101, 323232323))
    Fraction(5, 16)
    """
    if args.round_fractions is None:
        return x
    else:
        return x.limit_denominator(10 ** args.round_fractions)


def main():
    # Be nice about pipes and don't complain
    signal(SIGPIPE, SIG_DFL)

    start = args.start
    dimension = args.dimension

    tr_gen = inv_tr_nums(start, dimension)
    gap_gen = inv_gap_nums(start, dimension)

    while True:
        print(f'{pp(next(tr_gen))} {pp(next(gap_gen))}')
        # Be nice about pipes and do not buffer
        stdout.flush()


def parse_args():
    def parse_fraction(value):
        try:
            return Fraction(value)
        except ValueError:
            raise ArgumentTypeError(f"Invalid fraction value: {value}")

    parser = ArgumentParser(
        description='Print inverse triangular numbers and their gaps.'
    )
    parser.add_argument(
        '-d',
        '--dimension',
        type=parse_fraction,
        default=2,
        metavar='DIM',
        help='generate %(metavar)s-dimensional triangular numbers, can be '
             'non-integral (default: %(default)s)'
    )
    parser.add_argument(
        '-i',
        '--start',
        type=parse_fraction,
        default=1,
        metavar='POS',
        help='start at the %(metavar)s-th triangular number, can be '
             'non-integral (default: %(default)s)'
    )
    parser.add_argument(
        '-r',
        '--round-fractions',
        type=int,
        default=None,
        metavar='DIGITS',
        help='round floating point denominators to %(metavar)s digits'
    )
    parser.add_argument(
        '-T',
        '--unit-tests',
        action='store_true',
        help='run unit tests instead of printing'
    )

    return parser.parse_args()


def unit_tests():
    from doctest import testmod
    testmod()


if __name__ == '__main__':
    args = parse_args()

    if args.unit_tests:
        unit_tests()
    else:
        main()
