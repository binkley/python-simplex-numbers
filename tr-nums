#!/usr/bin/env python
import typing
from argparse import ArgumentDefaultsHelpFormatter, ArgumentParser, \
    ArgumentTypeError
from fractions import Fraction
from functools import lru_cache
from itertools import islice
from signal import SIGPIPE, SIG_DFL, signal
from sys import stdout

import scipy

DEFAULT_MAX_NUMBERS = 10

Generator = typing.Generator[Fraction, None, None]
Number = typing.Union[Fraction, float, int]


@lru_cache(maxsize=None)
def gamma(x: Number):
    """
    A memoized version of the Gamma function to improve performance.
    Note the return type to aid in chaining floating point operations.

    :param x: A value for which to compute the gamma function.
    :type x: Fraction | float | int

    :return: The computed value of Gamma(x).
    :rtype: float

    :Examples:
    >>> gamma(1)
    1.0
    >>> gamma(2)
    1.0
    """
    return scipy.special.gamma(float(x))


def inv_tr_nums(n: Number, d: Number) -> Generator:
    """
    Generate inverse triangular numbers.

    :param n: The starting index for the triangular number sequence.
    :type n: Fraction | float | int
    :param d: The dimension for the generalized triangular number.
    :type d: Fraction | float | int

    :return: The next inverse triangular number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_tr_nums(1, 2)
    >>> next(gen)
    Fraction(1, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    while True:
        # yield d * beta(n, n + d)
        yield 1 / Fraction((gamma(n + d) / (gamma(n) * gamma(d + 1))))
        n += 1


def inv_gap_nums(n: Number, d: Number) -> Generator:
    """
    Generate the preceding "gap" number inverse triangular numbers.

    :param n: The starting index for the preceding gap number.
    :type n: Fraction | float | int
    :param d: The dimension for the preceding gap number.
    :type d: Fraction | float | int

    :return: The next preceding gap number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_gap_nums(1, 2)
    >>> next(gen)
    Fraction(0, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    x = Fraction(-1)
    gen_inv_tr_nums = inv_tr_nums(n, d)
    # Skip ahead -- DOES NOT WORK for negative indices!
    for _ in range(int(n - 1)):
        x += next(gen_inv_tr_nums)
    while True:
        x += next(gen_inv_tr_nums)
        yield x


def pp(x: Fraction):
    """
    Pretty print by possibly rounding the denominator and reducing to
    simplest terms.

    :param x: The number to possibly round.
    :type x: Fraction

    :return: The possibly rounded number.
    :rtype: Fraction

    :Examples:
    >>> args.round_fractions = 2
    >>> pp(Fraction(1, 2))
    Fraction(1, 2)
    >>> pp(Fraction(101010101, 323232323))
    Fraction(5, 16)
    """
    if args.round_fractions is None:
        return x
    else:
        return x.limit_denominator(10 ** args.round_fractions)


def main():
    # Be nice about pipes and don't complain
    signal(SIGPIPE, SIG_DFL)

    start = args.starting_index
    dimension = args.dimension

    if args.sequence_format:
        tr_gen = inv_tr_nums(start, dimension)
        gap_gen = inv_gap_nums(start, dimension)

        while True:
            print(f'{pp(next(tr_gen))} {pp(next(gap_gen))}')
            # Be nice about pipes and do not buffer
            stdout.flush()

    else:
        nums = args.max_numbers

        gen = inv_tr_nums(start, dimension)
        for num in islice(gen, nums):
            print(pp(num))
        print('---')
        gen = inv_gap_nums(start, dimension)
        for num in islice(gen, nums + 1):
            print(pp(num))


def parse_args():
    def parse_fraction(value):
        try:
            return Fraction(value)
        except ValueError:
            raise ArgumentTypeError(f"Invalid fraction value: {value}")

    parser = ArgumentParser(
        description='Print inverse triangular numbers and their gaps.',
        formatter_class=ArgumentDefaultsHelpFormatter
    )
    parser.add_argument(
        '-d',
        '--dimension',
        type=parse_fraction,
        default=2,
        metavar='DIM',
        help='generate triangular numbers of DIM dimension'
    )
    parser.add_argument(
        '-i',
        '--starting-index',
        type=parse_fraction,
        default=1,
        metavar='INDEX',
        help='start at the INDEX-th triangular number'
    )
    parser.add_argument(
        '-n',
        '--max-numbers',
        type=int,
        default=DEFAULT_MAX_NUMBERS,
        metavar='MAX',
        help='generate only MAX triangular numbers'
    )
    parser.add_argument(
        '-r',
        '--round-fractions',
        type=int,
        default=None,
        metavar='DIGITS',
        help='round floating point denominators to DIGITS digits'
    )
    parser.add_argument(
        '-S',
        '--sequence-format',
        action='store_true',
        help='format output for an infinite sequence'
    )
    parser.add_argument(
        '-T',
        '--unit-tests',
        action='store_true',
        help='run unit tests instead of printing'
    )

    return parser.parse_args()


def unit_tests():
    from doctest import testmod
    testmod()


if __name__ == '__main__':
    args = parse_args()

    if args.unit_tests:
        unit_tests()
    else:
        main()
