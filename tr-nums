#!/usr/bin/env python
import argparse
from fractions import Fraction
from functools import lru_cache
from itertools import islice
from typing import Union

import scipy

DEFAULT_MAX_NUMBERS = 10


@lru_cache(maxsize=None)
def gamma(x: Union[Fraction, float, int]):
    """
    A memoized version of the gamma function to improve performance.

    Parameters:
    x (Fraction): A value for which to compute the gamma function.

    Returns:
    float: The computed gamma value for the given x.
    Note the return type to aid in chaining floating point operations.

    Examples:
    >>> gamma(1)
    1.0

    >>> gamma(2)
    1.0
    """
    return scipy.special.gamma(float(x))


def inv_tr_nums(n: Union[Fraction, float, int], d: Union[Fraction, float, int]):
    """
    Generate inverse triangular numbers.

    Parameters:
    n (Fraction): The starting index for the triangular number sequence.
    d (Fraction): The dimension for the generalized triangular number.

    Yields:
    Fraction: The next inverse triangular number.

    Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_tr_nums(1, 2)
    >>> next(gen)
    Fraction(1, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    while True:
        # yield d * beta(n, n + d)
        yield 1 / Fraction((gamma(n + d) / (gamma(n) * gamma(d + 1))))
        n += 1


def inv_gap_nums(n: Union[Fraction, float, int],
                 d: Union[Fraction, float, int]):
    """
    Generate the preceding "gap" number inverse triangular numbers.

    Parameters:
    n (Fraction): The starting index for the triangular number sequence.
    d (Fraction): The dimension for the generalized triangular number.

    Yields:
    Fraction: The next preceding gap number.

    Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_gap_nums(1, 2)
    >>> next(gen)
    Fraction(0, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    x = Fraction(-1)
    gen_inv_tr_nums = inv_tr_nums(n, d)
    # Skip ahead -- DOES NOT WORK for negative indices!
    for _ in range(int(n - 1)):
        x += next(gen_inv_tr_nums)
    while True:
        x += next(gen_inv_tr_nums)
        yield x


def main():
    start = args.starting_index
    dimension = args.dimension
    nums = args.max_numbers

    gen = inv_tr_nums(start, dimension)
    for num in islice(gen, nums):
        print(num)
    print('---')
    gen = inv_gap_nums(start, dimension)
    for num in islice(gen, nums + 1):
        print(num)


def parse_args():
    def parse_fraction(value):
        try:
            return Fraction(value)
        except ValueError:
            raise argparse.ArgumentTypeError(f"Invalid fraction value: {value}")

    parser = argparse.ArgumentParser(
        description='Print inverse triangular numbers and their gaps.'
    )
    parser.add_argument(
        '-d',
        '--dimension',
        type=parse_fraction,
        default=Fraction(2),
        metavar='DIM',
        help='generate triangular numbers of DIM dimension'
    )
    parser.add_argument(
        '-i',
        '--starting-index',
        type=parse_fraction,
        default=Fraction(1),
        metavar='INDEX',
        help='start at the INDEX-th triangular number'
    )
    parser.add_argument(
        '-n',
        '--max-numbers',
        type=int,
        default=DEFAULT_MAX_NUMBERS,
        metavar='MAX',
        help='generate only MAX triangular numbers'
    )
    parser.add_argument(
        '-T',
        '--unit-tests',
        action='store_true',
        help='run unit tests instead of printing'
    )
    return parser.parse_args()


def unit_tests():
    import doctest
    doctest.testmod()


if __name__ == '__main__':
    args = parse_args()

    if args.unit_tests:
        unit_tests()
    else:
        main()
