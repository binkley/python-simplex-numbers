#!/usr/bin/env python
import sys
from argparse import ArgumentParser, ArgumentTypeError
from fractions import Fraction
from functools import lru_cache
from signal import SIGINT, SIGPIPE, SIG_DFL, signal
from sys import argv, stderr, stdout
from typing import Callable, Iterator, NoReturn, Union

import scipy
from numpy import isinf, isnan

FractionStr = Callable[[Fraction], str]
Number = Union[Fraction, float, int]
NumberGenerator = Iterator[Fraction]


@lru_cache(maxsize=None)
def gamma(x: Number):
    """
    A memoized version of the Gamma function to improve performance.
    Note the return type to aid in chaining floating point operations.

    :param x: A value for which to compute the gamma function.
    :type x: Fraction | float | int

    :return: The computed value of Gamma(x).
    :rtype: float

    :Examples:
    >>> gamma(1)
    1.0
    >>> gamma(2)
    1.0
    >>> gamma(4)
    6.0
    >>> gamma(0)
    Traceback (most recent call last):
        ...
    ValueError: Gamma function explodes at 0
    >>> gamma(-1)
    Traceback (most recent call last):
        ...
    ValueError: Gamma function explodes at -1
    """
    g = scipy.special.gamma(float(x))

    if not isnan(g) and not isinf(g):
        return g

    raise ValueError(f'Gamma function explodes at {x}')


def inv_tr_nums(n: Number, d: Number) -> NumberGenerator:
    """
    Generate inverse triangular numbers.
    Avoid negative integer positions and zero.

    :param n: The starting position for the triangular number sequence.
    :type n: Fraction | float | int
    :param d: The dimension for the generalized triangular number.
    :type d: Fraction | float | int

    :return: The next inverse triangular number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_tr_nums(1, 2)
    >>> next(gen)
    Fraction(1, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    >>> # Negative triangular numbers
    >>> gen = inv_tr_nums(-0.5, 2)
    >>> next(gen)
    Fraction(-8, 1)
    """
    while True:
        # yield d * beta(n, n + d)
        yield 1 / Fraction((gamma(n + d) / (gamma(n) * gamma(d + 1))))
        n += 1


def inv_gap_nums(n: Number, d: Number) -> NumberGenerator:
    """
    Generate the preceding "gap" number inverse triangular numbers.

    :param n: The starting position for the preceding gap number.
    :type n: Fraction | float | int
    :param d: The dimension for the preceding gap number.
    :type d: Fraction | float | int

    :return: The next preceding gap number.
    :rtype: Fraction

    :Examples:
    >>> # Standard triangular numbers
    >>> gen = inv_gap_nums(1, 2)
    >>> next(gen)
    Fraction(0, 1)
    >>> next(gen)
    Fraction(1, 3)
    >>> # Fractional dimension triangular numbers
    >>> gen = inv_tr_nums(2, 2.5)
    >>> next(gen)
    Fraction(2, 7)
    """
    tr_gen = inv_tr_nums(n, d)

    # TODO: Broken
    gap = Fraction(-1)
    # Skip ahead -- DOES NOT WORK for negative indices!
    for _ in range(int(n - 1)):
        gap += next(tr_gen)

    while True:
        gap += next(tr_gen)
        yield gap


def fraction_str_patch(self: Fraction,
                       original_str: FractionStr = Fraction.__str__) \
        -> str:
    """
    Pretty print by possibly rounding the denominator and reducing to
    simplest terms.

    :param self: The fraction to possibly round.
    :type self: Fraction
    :param original_str: The original ``__str__`` method.
    :type original_str: FractionStr

    :return: The possibly rounded fraction as a string.
    :rtype: Fraction

    :Examples:
    >>> args.round_fractions = 2
    >>> fraction_str_patch(Fraction(1, 2))
    '1/2'
    >>> fraction_str_patch(Fraction(101, 323))
    '5/16'
    >>> args.floating_point = True
    >>> fraction_str_patch(Fraction(1, 2))
    '0.5'
    """
    if args.floating_point:
        return str(float(self))
    elif args.round_fractions is None:
        return original_str(self)
    else:
        return original_str(self.limit_denominator(10 ** args.round_fractions))


def setup_globals():  # pragma: no cover
    # Be nice about ^C and pipes
    signal(SIGINT, SIG_DFL)
    signal(SIGPIPE, SIG_DFL)

    # Turn tracebacks to standard script error messages
    def handle_exceptions(_, exception, __) -> NoReturn:
        print(f'{argv[0]}: {type(exception).__name__}: {exception}',
              file=stderr)
        exit(1)

    sys.excepthook = handle_exceptions
    # Monkey patch Fraction to respect rounding flags
    Fraction.__str__ = fraction_str_patch


def main():  # pragma: no cover
    setup_globals()

    start = args.start
    dimension = args.dimension

    tr_gen = inv_tr_nums(start, dimension)
    gap_gen = inv_gap_nums(start, dimension)

    while True:
        print(f'{next(tr_gen)} {next(gap_gen)}')
        stdout.flush()


def parse_fraction(value: str) -> Fraction:
    """
    Parse a potential fraction.
    Values cannot be 0 or negative integers (Gamma function explodes).

    :param value: the number-like string to turn into a fraction.
    :type value: str

    :return: the corresponding fraction.
    :rtype: Fraction

    :Examples:
    >>> parse_fraction('1')
    Fraction(1, 1)
    >>> parse_fraction('1/2')
    Fraction(1, 2)
    >>> parse_fraction('-0.5')
    Fraction(-1, 2)
    >>> parse_fraction('0')
    Traceback (most recent call last):
        ...
    argparse.ArgumentTypeError: 0 and negative integers explode: 0
    >>> parse_fraction('-1')
    Traceback (most recent call last):
        ...
    argparse.ArgumentTypeError: 0 and negative integers explode: -1
    >>> parse_fraction('pi')
    Traceback (most recent call last):
        ...
    argparse.ArgumentTypeError: Invalid fraction value: pi
    """
    try:
        f = Fraction(value)
        if f.is_integer() and f <= 0:
            raise ArgumentTypeError(
                f'0 and negative integers explode: {value}')
        return f
    except ValueError:
        raise ArgumentTypeError(f'Invalid fraction value: {value}')


def parse_args():  # pragma: no cover
    parser = ArgumentParser(
        description='Print inverse triangular numbers and their gaps.'
    )
    group = parser.add_mutually_exclusive_group()

    parser.add_argument(
        '-d',
        '--dimension',
        type=parse_fraction,
        default=2,
        metavar='DIM',
        help='generate %(metavar)s-dimensional triangular numbers, can be '
             'non-integral (default: %(default)s)'
    )
    group.add_argument(
        '-f',
        '--floating-point',
        action='store_true',
        help='print floating point numbers instead of fractions'
    )
    parser.add_argument(
        '-n',
        '--start',
        type=parse_fraction,
        default=1,
        metavar='POS',
        help='start at the %(metavar)s-th triangular number, can be '
             'non-integral (default: %(default)s)'
    )
    group.add_argument(
        '-r',
        '--round-fractions',
        type=int,
        default=None,
        metavar='DIGITS',
        help='round floating point denominators to %(metavar)s digits'
    )
    parser.add_argument(
        '-T',
        '--unit-tests',
        action='store_true',
        help='run unit tests instead of printing'
    )

    return parser.parse_args()


def unit_tests():
    from doctest import testmod
    testmod()


if __name__ == '__main__':
    args = parse_args()

    if args.unit_tests:
        unit_tests()
    else:
        main()  # pragma: no cover
